# 修复产品编号生成和输入框样式问题

## 问题分析

### 正确代码的关键部分

1. **产品编号生成规则**：
   - 规则：P+4位递增数字，超过9999后从10000继续递增
   - 支持手动编辑
   - 自动预先生成并填入输入框

2. **输入框样式**：
   - 使用Ant Design的Form.Item和Input组件
   - 可能使用了Space.Compact组件来组合输入框和重新生成按钮
   - 输入框占位符："自动生成（P+4位数字），可编辑"

3. **填入规则**：
   - 新增产品时自动生成并填入
   - 编辑产品时显示当前产品的编号
   - 支持手动编辑
   - 点击重新生成按钮可以重新生成

### 当前问题

1. **产品编号输入框为空**：
   - 新增产品时没有自动生成
   - 编辑产品时没有显示当前产品的编号
   - 点击重新生成按钮也没有反应

2. **输入框样式问题**：
   - 可能没有使用Space.Compact组件
   - 或者样式不符合预期

3. **后端API问题**：
   - 后端的generate-code API可能没有正确返回产品编号
   - 或者返回的格式不符合预期

## 修复方案

### 1. 修复ProductForm组件

**核心修改**：
- 确保输入框使用Space.Compact组件组合
- 确保产品编号生成逻辑正确
- 确保编辑模式下显示当前产品的编号
- 确保重新生成按钮正常工作

**代码修改**：
```typescript
// ProductForm.tsx
const ProductForm: React.FC<ProductFormProps> = ({
  initialValues,
  onSubmit,
  onCancel,
  isEditing = false,
  visible = false,
}) => {
  const [form] = Form.useForm();
  const [generatingCode, setGeneratingCode] = React.useState(false);

  // 生成并填充产品编号
  const generateAndFillCode = async () => {
    try {
      setGeneratingCode(true);
      // 直接调用后端API生成产品编号
      const response = await fetch('http://localhost:8080/api/products/generate-code');
      if (!response.ok) {
        throw new Error('Failed to generate product code');
      }
      const data = await response.json();
      const code = data.code;
      form.setFieldValue('code', code);
    } catch (error) {
      console.error('Failed to generate product code:', error);
      // 生成失败时，使用默认值
      form.setFieldValue('code', 'P0001');
    } finally {
      setGeneratingCode(false);
    }
  };

  // 监听抽屉可见性变化，更新表单值
  React.useEffect(() => {
    if (visible) {
      if (isEditing && initialValues) {
        // 编辑模式：将initialValues设置到表单中
        form.setFieldsValue({
          ...initialValues,
          status: initialValues.status === 1
        });
      } else {
        // 新增模式：重置表单并生成产品编号
        form.resetFields();
        generateAndFillCode();
      }
    }
  }, [visible, isEditing, initialValues, form]);

  return (
    <Form
      form={form}
      layout="vertical"
      initialValues={{ ...initialValues, status: initialValues?.status ?? 1 }}
      onFinish={handleSubmit}
    >
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }}>
        <Form.Item
          name="code"
          label="产品编号"
          rules={[
            { required: true, message: '请输入产品编号' },
            {
              validator: async (_, value) => {
                if (value) {
                  // 验证产品编号唯一性
                  const response = await fetch(`http://localhost:8080/api/products/check-code?code=${encodeURIComponent(value)}${initialValues?.id ? `&id=${initialValues.id}` : ''}`);
                  if (!response.ok) {
                    throw new Error('Failed to check product code');
                  }
                  const data = await response.json();
                  if (!data.isUnique) {
                    throw new Error('产品编号已存在，请使用其他编号');
                  }
                }
              },
              validateTrigger: ['onChange', 'onBlur']
            }
          ]}
        >
          <Space.Compact style={{ width: '100%' }}>
            <Input 
              placeholder="自动生成（P+4位数字），可编辑" 
            />
            {generatingCode ? (
              <Spin size="small" />
            ) : (
              <Button 
                type="link" 
                size="small" 
                onClick={generateAndFillCode}
              >
                重新生成
              </Button>
            )}
          </Space.Compact>
        </Form.Item>
        {/* 其他表单字段 */}
      </div>
      {/* 表单底部按钮 */}
    </Form>
  );
};
```

### 2. 确保后端API正确实现

**核心要求**：
- 设计并实现高效的产品编号查询接口
- 实现编号递增算法
- 开发唯一性验证机制
- 添加事务处理确保并发场景下的编号唯一性

**代码示例**：
```go
// 生成产品编号API
func generateProductCodeAPI(c *gin.Context) {
  // 开始事务
  tx, err := database.DB.Begin()
  if err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to begin transaction"})
    return
  }
  defer tx.Rollback()

  // 获取当前最大的产品编号
  var maxCode string
  err = tx.QueryRow("SELECT MAX(code) FROM products WHERE code REGEXP '^P[0-9]+$'").Scan(&maxCode)
  if err != nil && err != sql.ErrNoRows {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to query max product code"})
    return
  }

  var nextCode string
  if maxCode == "" {
    // 系统无产品时，生成P0001
    nextCode = "P0001"
  } else {
    // 提取数字部分并递增
    numPart := maxCode[1:]
    currentNum, err := strconv.Atoi(numPart)
    if err != nil {
      // 格式错误时，从P0001开始
      nextCode = "P0001"
    } else {
      currentNum++
      // 判断是否超过P9999
      if currentNum > 9999 {
        // 超过P9999，使用P+5位数字
        nextCode = fmt.Sprintf("P%d", currentNum)
      } else {
        // 未超过P9999，继续使用P+4位数字
        nextCode = fmt.Sprintf("P%04d", currentNum)
      }
    }
  }

  // 验证编号唯一性
  var exists bool
  err = tx.QueryRow("SELECT EXISTS(SELECT 1 FROM products WHERE code = ?)", nextCode).Scan(&exists)
  if err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check product code uniqueness"})
    return
  }

  // 如果编号已存在，递归生成新编号
  if exists {
    generateProductCodeAPI(c)
    return
  }

  // 提交事务
  if err = tx.Commit(); err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
    return
  }

  c.JSON(http.StatusOK, gin.H{"code": nextCode})
}
```

### 3. 修复前端服务调用

**核心修改**：
- 确保productService.generateProductCode()方法正确实现
- 确保API_BASE_URL正确配置
- 确保错误处理机制完善

**代码示例**：
```typescript
// productService.ts
async generateProductCode(): Promise<string> {
  const response = await fetch(`${API_BASE_URL}/products/generate-code`);
  if (!response.ok) {
    throw new Error('Failed to generate product code');
  }
  const data = await response.json();
  return data.code;
}
```

## 实施步骤

1. **修复ProductForm组件**：
   - 确保输入框使用Space.Compact组件
   - 确保产品编号生成逻辑正确
   - 确保编辑模式下显示当前产品的编号
   - 确保重新生成按钮正常工作

2. **确保后端API正确实现**：
   - 检查generate-code API的实现
   - 确保编号生成算法正确
   - 确保事务处理机制完善
   - 确保唯一性验证机制有效

3. **修复前端服务调用**：
   - 确保productService.generateProductCode()方法正确实现
   - 确保API_BASE_URL正确配置

4. **验证修复结果**：
   - 测试新增产品时是否自动生成产品编号
   - 测试编辑产品时是否显示当前产品的编号
   - 测试点击"重新生成"按钮是否可以重新生成产品编号
   - 测试手动编辑产品编号是否正常
   - 测试产品编号唯一性验证是否有效

## 预期效果

- 新增产品时，自动生成产品编号并填充到输入框中
- 编辑产品时，显示当前产品的编号
- 输入框样式使用Space.Compact组件，左侧输入框，右侧重新生成按钮
- 点击"重新生成"按钮可以重新生成产品编号
- 支持手动编辑产品编号
- 产品编号生成规则：P+4位递增数字，超过9999后从10000继续递增
- 产品编号唯一性验证有效

## 修复原理

- 确保后端API正确生成产品编号
- 确保前端正确处理返回的结果
- 确保输入框样式和填入规则符合要求
- 确保编辑模式下显示当前产品的编号
- 确保重新生成按钮正常工作
- 确保产品编号唯一性验证有效

这个修复方案应该能够解决产品编号生成和输入框样式问题，让产品管理功能恢复正常。